#include <stdio.h>              // подключение библиотеки для ввода-вывода
#include <malloc.h>             // подключение библиотеки для динамического выделения памяти
#include "deque.h"                // подключение пользовательской библиотеки

udt *create_udt(udt *d) {               // функция, создающая динамический массив
    d = (udt *) malloc(sizeof(udt));    // выделение памяти
    d->first = d->last = -1;            // начальное и конечное значения массива
    d->size = 0;                        // размер массива
    return d;                           // возвращение массива
}

bool udt_empty(const udt *d) {          // функция проверки, пуст ли массив
    return d->size == 0;                // если размер равен нулю, то вернуть true, иначе - false
}

int udt_size(const udt *d) {            // функция, возвращающая размер массива
    return d->size;
}

bool udt_push_back(udt *d, data t) {    // функция добавления элемента в конец массива
    if (d->size == 10) {                // если размер массива равен 10, то вернуть false
        return false;
    }
    if (!d->size) {                     // если размер массива равен 0, то начальное и конечное значения массива равны 0
        d->last = d->first = 0;
    } else {                            // иначе увеличивается индекс конца массива на 1
        d->last = (d->last + 1) % 10;
    }
    d->arr[d->last] = t;                // добавление элемента в конец массива
    d->size++;                          // увеличение размера массива
    return true;                        // возвращение true
}

bool udt_push_front(udt *d, data t) {       // функция добавления элемента в начало массива
    if (d->size == 10) {                    // если размер массива равен 10, то вернуть false
        return false;
    }
    if (!d->size) {                         // если размер массива равен 0, то начальное и конечное значения массива равны 0
        d->first = d->last = 0;
    } else {                                // иначе уменьшается индекс начала массива на 1
        d->first = (10 + (d->first - 1) % 10) % 10;
    }
    d->arr[d->first] = t;                   // добавление элемента в начало массива
    d->size++;                              // увеличение размера массива
    return true;                            // возвращение true
}

bool udt_pop_front(udt *d) {
    if (!d->size) {
        return false;
    }
    if (d->size == 1) {
        d->first = d->last = -1;
        d->size--;
        return true;
    }
    d->first++;
    d->first %= 10;
    d->size--;
    return true;
}

bool udt_pop_back(udt *d) {                 // функция удаления последнего элемента массива
    if (!d->size) {                         // если размер массива равен 0, то вернуть false
        return false;
    }
    if (d->size == 1) {                     // если размер массива равен 1, то начальное и конечное значения массива равны -1
        d->first = d->last = -1;
        d->size--;
        return true;
    }
    d->last--;                              // уменьшение индекса конца массива на 1
    d->last = (10 + d->last % 10) % 10;     // вычисление индекса конца массива
    d->size--;                              // уменьшение размера массива
    return true;                            // возвращение true
}

data udt_top_left(udt *d) {             // функция возвращения первого элемента массива
    if (d->size) {                      // если размер массива не равен 0, то вернуть первый элемент массива
        return d->arr[d->first];
    }
}

data udt_top_right(udt *d) {            // функция возвращения последнего элемента массива
    if (d->size) {                      // если размер массива не равен 0, то вернуть последний элемент массива
        return d->arr[d->last];
    }
}

void udt_print(udt *d) {                    // функция печати массива
    printf("Key\\tValue\\n");               // вывод заголовка таблицы
    int size = udt_size(d);                 // размер массива
    for (int i = 0; i < size; i++) {        // перебор элементов массива
        data a = udt_top_left(d);           // сохранение первого элемента массива
        udt_pop_front(d);                   // удаление первого элемента массива
        printf("%d\\t", a.key);             // вывод ключа
        printf("%s\\n", a.value);           // вывод значения
        udt_push_back(d, a);                // добавление элемента в конец массива
    }
}
